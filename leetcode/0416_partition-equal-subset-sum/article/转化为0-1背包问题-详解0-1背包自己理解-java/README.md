"+++
title = "0416. Partition Equal Subset Sum (转化为0-1背包问题) 详解0-1背包+自己理解 Java "
author = ["xie-ding-e-de-mao-zhu-o"]
date = 2020-09-30T02:40:34+08:00
tags = ["Leetcode", "Algorithms", "Java", "DynamicProgramming"]
categories = ["leetcode"]
draft = false
+++

# (转化为0-1背包问题) 详解0-1背包+自己理解 Java

> [0416. Partition Equal Subset Sum](https://leetcode-cn.com/problems/partition-equal-subset-sum/)
> [(转化为0-1背包问题) 详解0-1背包+自己理解 Java](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/zhuan-hua-wei-0-1bei-bao-wen-ti-xiang-jie-0-1bei-b/) by [xie-ding-e-de-mao-zhu-o](https://leetcode-cn.com/u/xie-ding-e-de-mao-zhu-o/)

# 动态规划 转化为0-1背包问题
    **首先讲解一下0-1背包问题** 这部分是copy背包九讲同时结合自己的部分见解,需要的朋友可以去看https://blog.csdn.net/stack_queue/article/details/53544109
##  01背包问题

题目

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

**基本思路**

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即f\[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：

```
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
```

这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f\[i-1][v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f\[i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。

**优化空间复杂度**

以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。

先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f\[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f\[i][v]呢？f\[i][v]是由f\[i-1][v]和f\[i-1][v-c[i]]两个子问题递推而来，能否保证在推f\[i][v]时（也即在第i次主循环中推f[v]时）能够得到f\[i-1][v]和f\[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0(注:从后向前)的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f\[i-1][v-c[i]]的值。伪代码如下：

```java
for i=1..N

  for v=V..0

​    f[v]=max{f[v],f[v-c[i]]+w[i]};
```

其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f\[i][v]=max{f\[i-1][v],f\[i-1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的

f\[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f\[i][v]由f\[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

```Text
这里还是有必要解释一下的，如果从前面往后推的话f[i][v]会受到前面已经改变的值的影响，但是01背包问题确是只选择要或者不要，所以先更新后面的状态，再更新前面的状态，使得状态之间不会想回影响。
```

事实上，使用一维数组解01背包的程序在后面会被多次用到，所以这里抽象出一个处理一件01背包中的物品过程，以后的代码中直接调用不加说明。

过程ZeroOnePack，表示处理一件01背包中的物品，两个参数cost、weight分别表明这件物品的费用和价值。

```java
procedure ZeroOnePack(cost,weight)

  for v=V..cost

​    f[v]=max{f[v],f[v-cost]+weight}
```

注意这个过程里的处理与前面给出的伪代码有所不同。前面的示例程序写成v=V..0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为cost的物品不会影响状态f[0..cost-1]，这是显然的。

有了这个过程以后，01背包问题的伪代码就可以这样写：

```java
for i=1..N

  ZeroOnePack(c[i],w[i]);
```
**初始化的细节问题**

我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。

如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。

如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。

为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是

-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。

这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。

小结

01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。

----
**讲完了0-1背包，我们来自己做出这道题目**
我们将按照

1. 思考状态转移方程
2. 编程
3. 思考优化空间复杂度的顺序来解题
建议先看题目思考一下，然后再看解析

做题前，首先我们来排除特殊情况。①如果所有的数字加起来是奇数，那么铁定不能分割为等和子集，这种情况就可以直接返回false。②如果这个子集只有0或者1个数字，那么也可以直接返回false；
1. 思考状态转移方程

   ```
   dp[i][j]=max(dp[i-1][j],（dp[i-1][j-nums[i]]+nums[i]）) //其中j>=nums[i]
   ```

   

其中i代表nums数组元素的个数，j相当于背包的容量，不过j是从0开始的

我们可以轻松的得知i=nums.length;那么j是多少呢？

看题目，分割成相等的子序列，即每个子序列的值应该是所有nums的值加起来的一半

如果我们把这道题看成背包问题，所有的nums的值加起来的一半是背包容量，nums[i]是物品的费用同时也是容量。且背包需要被装满。

只要最后的位置dp\[i-1][j]==sum(nums)/2就说明可以分割

2. 有了状态方程后就很容易变成了，注意细节问题，要把背包填满，上面也已经提到过了，第一行除了第一个是0，其他的初始化为

   -∞

给出代码：

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        //少于1个肯定不能分割
        if (len <= 1) return false;
        int sum = 0;
        for (int num : nums)
            sum += num;
        //如果是奇数也不能分割
        if (sum % 2 != 0)
            return false;
        int target = sum / 2;   //target应该是数组分成两个部分应该达到的值
        int[][] dp = new int[len][target + 1];
        //初始化为-∞,记住dp[0][0]为0,因为Java默认是0,跳过即可
        for (int i = 1; i <= target; i++) {
            dp[0][i] = Integer.MIN_VALUE;
        }
        //但是nums[0]是可以填充满的
        dp[0][nums[0]] = nums[0];
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {
              //状态方程的转移
                if(j>=nums[i])
                    dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]);
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[len - 1][target] == target;
    }
}

```

时间复杂度:O(NC),空间复杂度O(NC)。N是数组元素个数，C是所有数组之和的一半
理解动态规划的方法是手动填写数组，这里给出题目示例的数组

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | -∞   | -∞   | -∞   | -∞   | -∞   | -∞   | -∞   | -∞   | -∞   | -∞   |
| 5    | 0    | 1    | -∞   | -∞   | -∞   | 5    | 6    | -∞   | -∞   | -∞   | -∞   | -∞   |
| 11   | 0    | 1    | -∞   | -∞   | -∞   | 5    | 6    | -∞   | -∞   | -∞   | -∞   | 11   |
| 5    | 0    | 1    | -∞   | -∞   | -∞   | 5    | 6    | -∞   | -∞   | -∞   | -∞   | 11   |
3. 思考空间优化

这道题目也是可以进行空间优化的，让我们仔细观察状态转移方程

```
dp[i][j]=max(dp[i-1][j],（dp[i-1][j-nums[i]]+nums[i]）) //其中j>=nums[i]
```

可以发现dp\[i][j]只和上一行和上一行前面的部分值有关

根据前面背包问题提到的优化空间复杂度的方法， 我们可以把数组改成

```java
int[] dp = new int[target + 1];
//不要忘记初始化
for (int i = 1; i <= target; i++) {
      dp[i] = Integer.MIN_VALUE;
}
//nums[0]是可以填充满的
dp[nums[0]] = nums[0];
```

你可以发现上面的代码就是第一行的状态了

如何更新第二行代码呢，我们刚才分析过了dp\[i][j]只和上一行和上一行前面的部分值有关，我们可以从后向前更新

```java
for (int i = 1; i < len; i++) {
            for (int j = target; j >= 0; j--) {
                if (j >= nums[i])
                    dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
```
----
为什么不从前向后更新呢，这里借用一下[@providence-2](/u/providence-2/)的评论
这里可能会有人困惑为什么压缩到一维时，要采用逆序。因为在一维情况下，是根据 dp[j] || dp[j - nums[i]]来推d[j]的值，如不逆序，就无法保证在外循环 i 值保持不变 j 值递增的情况下，dp[j - num[i]]的值不会被当前所放入的nums[i]所修改，当j值未到达临界条件前，会一直被nums[i]影响，也即是可能重复的放入了多次nums[i]，为了避免前面对后面产生影响，故用逆序。 举个例子，数组为[2,2,3,5]，要找和为6的组合，i = 0时，dp[2]为真，当i自增到1，j = 4时，nums[i] = 2,dp[4] = dp[4] || dp[4 - 2]为true，当i不变，j = 6时,dp[6] = dp [6] || dp [6 - 2],而dp[4]为true，所以dp[6] = true,显然是错误的。 故必须得纠正在正序情况下，i值不变时多次放入nums[i]的情况。

觉得空间优化难以理解？最好的办法是手动模拟一下，这里就不给出表格了。

-----

给出代码
```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        //少于1个肯定不能分割
        if (len <= 1) return false;
        int sum = 0;
        for (int num : nums)
            sum += num;
        //如果是奇数也不能分割
        if (sum % 2 != 0)
            return false;
        int target = sum / 2;   //target应该是数组分成两个部分应该达到的值
        int[] dp = new int[target + 1];
        //初始化为-∞,记住dp[0][0]为0,因为Java默认是0,跳过即可
        for (int i = 1; i <= target; i++) {
            dp[i] = Integer.MIN_VALUE;
        }
        //但是nums[0]是可以填充满的
        dp[nums[0]] = nums[0];
        for (int i = 1; i < len; i++) {
            for (int j = target; j >= 0; j--) {
                if (j >= nums[i])
                    dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```

写在最后，没想到林林总总分析思路打了这么多字，我可能不是最快的解题也不是空间复杂度最好的，我就是讲解一下动态规划的思路。如果你看了我这篇题解有所启发，那就是我最大的慰藉了。